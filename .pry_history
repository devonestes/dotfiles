dependency_rows
continue
next
quit
dependency_rows
quit
dependency_hash
each_node = lambda {|&b| g.each_key(&b) }
each_child = lambda {|n, &b| g[n].each(&b) }
each_node = lambda { |&b| dependency_hash.each_key(&b) }
each_child = lambda { |n, &b| dependency_hash[n].each(&b) }
require 'tsort'
TSort
TSort.tsort(each_node, each_child)
each_node.next
each_node.call
each_node.call.next
each_node.call.next.next
each_node.call.next.next.next
enu = each_node.call
enu.next
dependency_hash
g = dependency_hash
g
each_node = lambda {|&b| g.each_key(&b) }
each_child = lambda {|n, &b| g[n].each(&b) }
TSort.tsort(each_node, each_child)
en = each_child.call
en = each_child.call('public.fourth')
en.next
en = each_child.call('public.third')
en.next
en = each_child.call('public.second')
en.first
en.next
en = each_child.call('public.first')
dependency_rows
quit
dependency_hash
quit
dependency_hash
g = dependency_hash
each_node = lambda {|&b| g.each_key(&b) }
each_child = lambda {|n, &b| g[n].each(&b) }
p TSort.tsort(each_node, each_child)
quit
deps
idx
dependencies[0..idx]
dependencies[0...idx]
quit
timeline
timeline[0]
timeline[0].methods
timeline[0].id
timeline[0].text
timeline[0].created_at
DateTime.today
DateTime.now
DateTime.now < timeline[0].created_at
Time.now < timeline[0].created_at
(Time.now - 1.week) < timeline[0].created_at
Time.now - 1.day
Time.now - 1.days
1.methods.sort
Time.now - 1
Time.now - 2
Time.now - 300
Time.now - 10
Time.now - (60 * 60 * 24 * 10)
Time.now - (60 * 60 * 24 * 7)
(Time.now - 60 * 60 * 24 * 7) < timeline[0].created_at
(Time.now - 60 * 60 * 24 * 7) > timeline[0].created_at
one_week_ago = (Time.now - 60 * 60 * 24 * 7)
timeline[0] < one_week_ago
timeline[0].created_at < one_week_ago
quit
